---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.10.3
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
execution:
  timeout: 180
---

# Exercise 1: Finding Michel Electrons

Michel electrons come out of a muon decay. They are electrons, so they look like an electromagnetic shower coming out of a long muon track.

```{note}
Need refresh to make sure we get a decent spectrum at the end of the tutorial.
```

### Requirements:
 * U-ResNet for Semantic Segmentation

+++

## I. Motivation

Michel electrons are used in LArTPC experiments as “candles”: we understand their energy spectrum very well, so they can be used to calibrate the detector and to compare the quality of different detectors. Michel electrons spectrum is one of the first “tokens” that an experiment will show to prove that the detector is running and we can successfully reconstruct the data. Since their energy is in a range up to ~50MeV, they are also representative of the detector response to electromagnetic particles generated by neutrino activity. 

```{figure} https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQsezzzPeMfyra-aaqqooRh-IAVN61XbgDDuQ&usqp=CAU
Example of Michel electron spectrum
```


### What are we looking for? 

```{figure} ./electron_stopping_power.png
---
figclass: margin
---
Energy loss per unit distance (MeV/cm) for electrons traveling in liquid argon. From {cite}`MicrobooneMichel`.
```

The primary Michel electron that comes out of the muon decay-at-rest can lose energy either through ionization (collision stopping power), or through the production of radiative photons via Bremsstrahlung (radiative stopping power). Beyond a certain energy, the radiative stopping power is greater than the collision stopping power. If the radiative photons have enough energy, they can pair-produce, i.e. turn into an electron-positron pair. They, in turn, can produce new radiative photons, and so on. They can also undergo Compton scattering. A cascade of electrons and photons (electromagnetic shower) happens.

Ionization produces track-like energy depositions, whereas the photons can travel some distance before converting into a secondary electron. Hence Michel electrons have two clear topological features: a primary ionization, which is track-like at the end of the muon track, and some scattered energy deposits much further away which come from these radiative photons.

In this exercise, we are only concerned with finding the primary ionization of the Michel electron. We will purposefully ignore for now the radiative photons.

```{figure} ./michel.png
---
height: 300px
---
Example of Michel electron topology
```

## II. Setup

We first need to set the working environment and the path to the validation dataset.

```{code-cell} ipython3
import os, sys
SOFTWARE_DIR = '%s/lartpc_mlreco3d' % os.environ.get('HOME') # Path to your `lartpc_mlreco3d`
DATA_DIR = os.environ.get('DATA_DIR')
# Set software directory
sys.path.append(SOFTWARE_DIR)
```

We will also need `Plotly` for visualization:

```{code-cell} ipython3
import numpy as np
import matplotlib.pyplot as plt 
import yaml

import plotly
import plotly.graph_objs as go
from plotly.subplots import make_subplots
from plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot
init_notebook_mode(connected=False)
```

The imports below load some auxiliary functions and classes required to run the full chain in interactive mode. 

```{code-cell} ipython3
from mlreco.main_funcs import process_config, prepare
import warnings
warnings.filterwarnings('ignore')
```

Let's load the configuration file to setup the full chain architecture and weights. 

```{code-cell} ipython3
cfg = yaml.load(open('%s/inference.cfg' % DATA_DIR, 'r').read().replace('DATA_DIR', DATA_DIR),Loader=yaml.Loader)
process_config(cfg, verbose=False)
```

This cell loads the dataset and the model to the notebook environment. Optionally, you can specifiy the list of images by listing the image ID numbers:
```
prepare(cfg, event_list=[0, 1, 2, ...]
```
If the model's trained weights have been loaded correctly, it should display a message like this (`$PATH_TO_WEIGHTS` will be replaced by wherever you placed your trained full chain weights):
> Restoring weights for from `$PATH_TO_WEIGHTS`...
> Done.

```{code-cell} ipython3
# prepare function configures necessary "handlers"
hs = prepare(cfg)
dataset = hs.data_io_iter
```

We can perform one forward iteration of the chain as follows:

```{code-cell} ipython3
data, result = hs.trainer.forward(dataset)
```

The input data and label information are loaded onto the `data_blob` variable, while the outputs from the chain are stored inside `result`.

+++

## III. Setup the Evaluator

+++

For the tutorial, we will use the analysis tools developed for easier handling of the full chain outputs.

```{code-cell} ipython3
from analysis.classes.ui import FullChainEvaluator
```

As we did before in the Analysis Tools tutorial, let's setup the `FullChainEvaluator` with deghosting turned on:

```{code-cell} ipython3
predictor = FullChainEvaluator(data, result, cfg, deghosting=True)
```

```{code-cell} ipython3
entry = 8
```

## IV. Selecting Michel Electrons

### Step 1: Extract the semantic segmentation predictions.

+++

Let's first import plotting libraries for visualization:

```{code-cell} ipython3
from mlreco.visualization import scatter_points, scatter_cubes, plotly_layout3d
from mlreco.visualization.plotly_layouts import white_layout, trace_particles, trace_interactions, dualplot
```

The evaluator will handle ghost masking internally, so all you have to do is retrieve the predicted and true semantic segmentation labels for visualization and analysis:

```{code-cell} ipython3
pred = predictor._fit_predict_semantics(entry)
truth = predictor.get_true_label(entry, 'segment_label')
points = predictor.data_blob['input_data'][entry]
# Check if dimensions agree
assert (pred.shape[0] == truth.shape[0])
```

Let's plot the true and predicted semantic labels side-by-side:

```{code-cell} ipython3
trace1, trace2 = [], []
edep = points[:, 5]

trace1 += scatter_points(points,
                        markersize=1,
                        color=truth, 
                        cmin=0, cmax=5, colorscale='rainbow')

trace2 += scatter_points(points,
                        markersize=1,
                        color=pred, 
                        cmin=0, cmax=5, colorscale='rainbow')

fig = dualplot(trace1, trace2, titles=['True semantic labels (true no-ghost mask)', 'Predicted semantic labels (predicted no-ghost mask)' ])

iplot(fig)
```

The true labels are plotted in the left, predicted on the right

+++

### Step 2. Identify muons and electrons.

By default, the label for tracks and michel electrons are 1 and 2, respectively.

```{code-cell} ipython3
track_label = 1
michel_label = 2
```

```{code-cell} ipython3
particles = predictor.get_particles(entry, primaries=False)
true_particles = predictor.get_true_particles(entry, primaries=False, verbose=False)
```

Let's look at the list of reconstructed (predicted) particles:

```{code-cell} ipython3
trace1 = trace_particles(particles)
trace2 = trace_particles(true_particles)
```

```{code-cell} ipython3
fig = make_subplots(rows=1, cols=2,
                    specs=[[{'type': 'scatter3d'}, {'type': 'scatter3d'}]],
                    horizontal_spacing=0.05, vertical_spacing=0.04)
fig.add_traces(trace1, rows=[1] * len(trace1), cols=[1] * len(trace1))
fig.add_traces(trace2, rows=[1] * len(trace2), cols=[2] * len(trace2))
fig.layout = white_layout()
fig.update_layout(showlegend=False,
                  legend=dict(xanchor="left"),
                 autosize=True,
                 height=600,
                 width=1500,
                 margin=dict(r=20, l=20, b=20, t=20))
iplot(fig)
```

And the true particles:

```{code-cell} ipython3
true_particles
```

Ok, so we see that there is one predicted and true Michel electron in this image. We should first check if the two michel electrons actually correspond to one another. To see this, we first have to match all particles with one another:

```{code-cell} ipython3
matches = predictor.match_particles(entry, primaries=False)
def get_michels(matches):
    michels = []
    # Check if the predicted and true michels actually match to one another:
    for m in matches:
        if m[0].semantic_type == michel_label:
            michels.append(m[0])
    return michels
```

```{code-cell} ipython3
michels = get_michels(matches)
```

### Step 3. Check if the Michel electron is adjacent to the end of a muon track.

+++

To check if our candidate michel is actually adjacent to a track, we can set a minimum distance threshold between the michel electron and the track. 

> Wait, what if it was a misclassified Delta ray electron?

Delta ray electrons are knock off electrons that can happen along the trajectory of a muon, so if UResNet mispredicted the delta ray voxels as Michel voxels we would be wrong! To avoid that, let’s also make sure that the point of contact is at the end of the track. Again, many ways to do this check, this is just one possible heuristic. 

If a `Particle` has a track semantic type, it will contain a (2 x 5) `endpoints` array as its attribute. The first three columns of `endpoints` are the voxel coordinates of the track's endpoints. Optionally, we can use this information to be more selective. 

I've wrote a function that checks if a michel electron is adjacent to a track in `check_michel_adjacency` as an example.

```{code-cell} ipython3
from scipy.spatial.distance import cdist

def check_michel_adjacency(michel_particles, particles, distance_threshold=10, check_endpoints=False):
    '''
    Given list of Michel electrons and list of particles,
    return a list of particle ids that are adjacent. 
    
    Inputs:
        - michel_particles (List[Particle]): list of michel electrons
        - particles (List[Particle]): list of particles 
        - distance_threshold: maximum distance to be considered adjacent
        - check_endpoints: option to use track endpoint information
        rather than Hausdorff distance.
        
    Returns:
        - adjacency_checks: list of particle ids that are
        adjacent to michels in <michel_particles> in order.
        If no adjacent tracks could be found, it will return 
        None instead of a particle id number (int). 
    '''
    # Check input michels are actually michels
    adjacency_checks = []
    for mp in michel_particles:
        is_adjacent = False
        if mp.semantic_type != 2:
            raise ValueError("Found non-michel particle {} with "\
                             "semantic type {} in list of michel electrons.".format(mp.id, mp.semantic_type))
        min_dist, adj_pid = np.inf, -1
        for p in particles:
            if p.semantic_type == 1:
                if check_endpoints:
                    dist = cdist(mp.points, p.endpoints[:, :3])
                else:
                    dist = cdist(mp.points, p.points)
                if dist.min() < min_dist:
                    min_dist = dist.min()
                    adj_pid = p.id
        if min_dist < distance_threshold:
            adjacency_checks.append(adj_pid)
        else:
            print("All candidate tracks are more than {}px apart from "\
                  "michel {}, minimum of {:.2f}px achieved for track {}".format(
                distance_threshold, mp.id, min_dist, adj_pid))
            adjacency_checks.append(None)
    return adjacency_checks
```

```{code-cell} ipython3
check_michel_adjacency(michels, particles, distance_threshold=10)
```

### Step 4: Make a plot

Let’s use the voxel count as a substitute for the reconstructed energy. This approximation is fairly accurate for shower-like particles. Make a histogram with Michel electron candidates voxel counts.

Since there are only so many Michel electrons per entry, you will need to loop over several entries, possibly more than a batch size worth of entries. Let's collect all michel electrons that have an adjacent track for 10 iterations-worth of data. 

```{code-cell} ipython3
iterations = 10
```

```{code-cell} ipython3
:tags: [hide-output]

all_candidates = []
for iteration in range(iterations):
    print("Iteration: {}...".format(iteration))
    data, result = hs.trainer.forward(dataset)
    # Initialize Evaluator"
    predictor = FullChainEvaluator(data, result, cfg, deghosting=True)
    for entry, index in enumerate(predictor.index):
        matches = predictor.match_particles(entry, primaries=False)
        particles = predictor.get_particles(entry, primaries=False)
        michels = get_michels(matches)
        adjacency = check_michel_adjacency(michels, particles)
        for i, m in enumerate(michels):
            if adjacency[i] is not None:
                all_candidates.append(m)
```

```{code-cell} ipython3
michel_voxel_counts = [p.points.shape[0] for p in all_candidates]
```

```{code-cell} ipython3
import matplotlib.pyplot as plt
import seaborn
seaborn.set(rc={
    'figure.figsize':(15, 10),
})
seaborn.set_context('talk')

plt.hist(michel_voxel_counts)
plt.xlabel("Voxel count")
plt.ylabel("Michel electron candidates")
```

```{code-cell} ipython3

```

## Optional: how well did we do?
You can keep the exercise going by looking at the true Michel candidates (same heuristic, using the
true semantic labels), matching them to the predicted Michel candidates and computing some metrics
such as purity (fraction of predicted candidates that are matched) or efficiency (fraction of true
Michel that find a match).

## Other readings
Michel Electron Reconstruction Using
Cosmic-Ray Data from the MicroBooNE LArTPC
https://lss.fnal.gov/archive/2017/pub/fermilab-pub-17-090-nd.pdf


```{bibliography}
:style: alpha
```